# -*- coding: utf-8 -*-
"""YOLO_loss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qg3g6V42dZdbM3hUrrORpnB0jq2laWAy
"""

"""
Orijinal YOLO makalesinden Yolo Kayıp Fonsiyonu Implementasyonu
"""

import torch
import torch.nn as nn
from utils import intersection_over_union


class YoloLoss(nn.Module):
    """
    Calculate the loss for yolo (v1) model
    """
    
    def __init__(self, S=7, B=2, C=20):
        super(YoloLoss, self).__init__()
        self.mse = nn.MSELoss(reduction="sum") #mean squared error 

        """
        S is split size of image (in paper 7), #7 grid 
        B is number of boxes (in paper 2),   #kutuların sayısı
        C is number of classes (in paper and VOC dataset is 20), # sınıfların sayısı üçü  de makalede belirtildiği gibi kullanılıyor
        """
        self.S = S
        self.B = B
        self.C = C

        # These are from Yolo paper, signifying how much we should
        # pay loss for no object (noobj) and the box coordinates (coord)
        self.lambda_noobj = 0.5 #obje yok
        self.lambda_coord = 5 

    def forward(self, predictions, target):
        # predictions are shaped (BATCH_SIZE, S*S(C+B*5) when inputted------ S,S,30 olarak yeniden şekillendirildiğinden emin olmak için yapıyoruz
        predictions = predictions.reshape(-1, self.S, self.S, self.C + self.B * 5)
                                          #-1 dedik çünkü reshape yapmak istemiyoruz kontrol etmek istiyoruz
        # Calculate IoU for the two predicted bounding boxes with target bbox
        #0dan 19a kadar sınıf,20 sınıf skoru, 21 25 arası bounding box değerleri,
        iou_b1 = intersection_over_union(predictions[..., 21:25], target[..., 21:25]) #21,22,23 ve 24ü alıyor
        iou_b2 = intersection_over_union(predictions[..., 26:30], target[..., 21:25]) #sadece bir tane hedef olduğu için yine 21den 25e kadar alcaz 
        ious = torch.cat([iou_b1.unsqueeze(0), iou_b2.unsqueeze(0)], dim=0) #sıralamak için yapıyoruz ve unsqueeze sıkıştırmak demek

        #  en iyi tahmini içeren en yüksek değerli iouyu al
        #en iyi kutu 0,1 indexlerinde olacak hangi kutu en iyisi göstermek için
        iou_maxes, bestbox = torch.max(ious, dim=0)
        exists_box = target[..., 20].unsqueeze(3)  # in paper this is Iobj_i #loss fonksiyonunu kontol etmek istediğimizden kullanıyoruz unsqueezei burada
        #obje var mı onu söyleyecek identity 


        # ======================== #
        #   FOR BOX COORDINATES    #  1 ve 2 formülde
        # ======================== #

        # Set boxes with no object in them to 0. We only take out one of the two 
        # predictions, which is the one with highest Iou calculated previously.
        box_predictions = exists_box * ( #hücrede nesne varsa bu işlemler yapılıyor yoksa yapılmıyor (identity)
            (
                bestbox * predictions[..., 26:30] #ikinci bounding box en iyiyse burası 1 olacak
                + (1 - bestbox) * predictions[..., 21:25] #birinci en iyiyse burası ilki doğruysa burası 0 olacak
            )
        )

        box_targets = exists_box * target[..., 21:25]

        # Take sqrt of width, height of boxes to ensure that
        box_predictions[..., 2:4] = torch.sign(box_predictions[..., 2:4]) * torch.sqrt( #genişlik ve yüksekliğin karekökünü aldığımız yer
            torch.abs(box_predictions[..., 2:4] + 1e-6) #negatif olmasın diye abs yani mutlak aldık  kökün içi sıfır olmasın diye de e'li kısmı ekledik 
        ) #bunlar tahminler içindi

        #nokta nokta yazan yerlerde normalde (N,S,S,4) yazıyor ya da   N,S,S,25 yukarda
        box_targets[..., 2:4] = torch.sqrt(box_targets[..., 2:4]) 
        #(N,S,S,4) ---> (N*S*S,4) yaparak düzleştirdik
        box_loss = self.mse(
            torch.flatten(box_predictions, end_dim=-2), #öndeki her şeyi düzleştirmek istediğimiz için -2 aldık
            torch.flatten(box_targets, end_dim=-2),
            #kutuların lossu için mean square erroru bulduk
        )





        # ==================== #
        #   FOR OBJECT LOSS    #  nesne kayıpları formülde 3 
        # ==================== #
        #Önce hangi bounding boxun sorumlu olduğunu buluyoruz yani IoU  yüksek değerli olanı
        
        pred_box = ( #tahmin değerini alıyor formülde 3 bestbox 0sa burası 1 oluyor 
            bestbox * predictions[..., 25:26] + (1 - bestbox) * predictions[..., 20:21]
        )
        #Sonra orada gerçekten kutu var mı bakıyoruz yani obje var mı (identity)
        #(N*S*S) 
        object_loss = self.mse(
            torch.flatten(exists_box * pred_box),
            torch.flatten(exists_box * target[..., 20:21]),
        )

        # ======================= #
        #   FOR NO OBJECT LOSS    # Formülde 4
        # ======================= #

        #max_no_obj = torch.max(predictions[..., 20:21], predictions[..., 25:26])
        #no_object_loss = self.mse(
        #    torch.flatten((1 - exists_box) * max_no_obj, start_dim=1),
        #    torch.flatten((1 - exists_box) * target[..., 20:21], start_dim=1),
        #)
        #(N,S,S,1) --> (N,s*s)

        no_object_loss = self.mse(
            torch.flatten((1 - exists_box) * predictions[..., 20:21], start_dim=1),
            torch.flatten((1 - exists_box) * target[..., 20:21], start_dim=1),
        )
        #2 farklı pmiz var onun ikisi için de yapıyoruz ayrı ayrı (p prediction yani tahmin)
        no_object_loss += self.mse(
            torch.flatten((1 - exists_box) * predictions[..., 25:26], start_dim=1),
            torch.flatten((1 - exists_box) * target[..., 20:21], start_dim=1)
        )

        # ================== #
        #   FOR CLASS LOSS   #   Formülde 5
        # ================== #
        #(N,S,S,20) --> (N*S*S,20) Her bir hücreyi ayrı bir örnek olarak inceliyoruz
        class_loss = self.mse( #Hücrede yani kutuda hangi obje var onu bulmak için bu kısmı yapıyoruz
            torch.flatten(exists_box * predictions[..., :20], end_dim=-2,),
            torch.flatten(exists_box * target[..., :20], end_dim=-2,),
        )


      #
      #Gerçek Loss 
      #
        loss = (
            self.lambda_coord * box_loss  # first two rows in paper formülde 1 ve 2
            + object_loss  #  formülde 3 
            + self.lambda_noobj * no_object_loss  #  formülde 4
            + class_loss  #formülde 5
        ) #hepsini topladık gerçek lossu bulduk

        return loss